<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/backend/delivery/api/v1/monitor_route.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/backend/delivery/api/v1/monitor_route.py" />
              <option name="originalContent" value="import cv2&#10;from flask import Blueprint, Response, jsonify, request&#10;from src.backend.dependencies.container import container&#10;from src.backend.utils.cv_tools import draw_overlays&#10;&#10;monitor_bp = Blueprint(&quot;monitor&quot;, __name__, url_prefix=&quot;/api/v1/monitor&quot;)&#10;&#10;&#10;def generate_frames():&#10;    &quot;&quot;&quot;Генератор видеопотока. БЕЗ cap.set для стабильности.&quot;&quot;&quot;&#10;    cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)&#10;&#10;    try:&#10;        while True:&#10;            success, frame = cap.read()&#10;            if not success:&#10;                break&#10;            frame = cv2.resize(frame, (640, 480))&#10;            try:&#10;                result = container.track_use_case.execute(frame)&#10;                frame_with_overlay = draw_overlays(frame, result)&#10;            except Exception as e:&#10;                print(f&quot;[ERROR] Ошибка в трекинге: {e}&quot;)&#10;                frame_with_overlay = frame&#10;&#10;            ret, buffer = cv2.imencode(&#10;                &quot;.jpg&quot;, frame_with_overlay, [cv2.IMWRITE_JPEG_QUALITY, 70]&#10;            )&#10;            frame_bytes = buffer.tobytes()&#10;&#10;            yield (&#10;                b&quot;--frame\r\n&quot;&#10;                b&quot;Content-Type: image/jpeg\r\n\r\n&quot; + frame_bytes + b&quot;\r\n&quot;&#10;            )&#10;    finally:&#10;        cap.release()&#10;&#10;&#10;@monitor_bp.route(&quot;/video_feed&quot;)&#10;def video_feed():&#10;    return Response(&#10;        generate_frames(), mimetype=&quot;multipart/x-mixed-replace; boundary=frame&quot;&#10;    )&#10;&#10;&#10;@monitor_bp.route(&quot;/logs&quot;, methods=[&quot;GET&quot;])&#10;def get_logs():&#10;    report = container.report_use_case.execute()&#10;    return jsonify(report)&#10;&#10;&#10;@monitor_bp.route(&quot;/groups&quot;, methods=[&quot;GET&quot;])&#10;def get_groups():&#10;    students = container.student_repo.get_all()&#10;    groups = {}&#10;    for s in students:&#10;        if s.group_name not in groups:&#10;            groups[s.group_name] = []&#10;        groups[s.group_name].append(&#10;            {&quot;id&quot;: s.id, &quot;name&quot;: s.name, &quot;photo&quot;: f&quot;/static/images/{s.id}.jpg&quot;}&#10;        )&#10;&#10;    for g in groups:&#10;        groups[g].sort(key=lambda x: x[&quot;name&quot;])&#10;    return jsonify(groups)&#10;&#10;&#10;@monitor_bp.route(&quot;/manual_status&quot;, methods=[&quot;POST&quot;])&#10;def manual_status():&#10;    data = request.json&#10;    student_id = data.get(&quot;student_id&quot;)&#10;    action = data.get(&quot;action&quot;)&#10;&#10;    from src.backend.domain.attendance.entity import AttendanceLog, EngagementStatus&#10;    from datetime import datetime&#10;&#10;    log = AttendanceLog(&#10;        id=None,&#10;        student_id=student_id,&#10;        timestamp=datetime.now(),&#10;        is_late=False,&#10;        engagement_score=(&#10;            EngagementStatus.HIGH if action == &quot;present&quot; else EngagementStatus.LOW&#10;        ),&#10;    )&#10;    container.attendance_repo.add_log(log)&#10;    return jsonify({&quot;status&quot;: &quot;updated&quot;})&#10;" />
              <option name="updatedContent" value="import cv2&#10;from flask import Blueprint, Response, jsonify, request&#10;from src.backend.dependencies.container import container&#10;from src.backend.utils.cv_tools import draw_overlays&#10;&#10;monitor_bp = Blueprint(&quot;monitor&quot;, __name__, url_prefix=&quot;/api/v1/monitor&quot;)&#10;&#10;&#10;def generate_frames():&#10;    &quot;&quot;&quot;Генератор видеопотока. БЕЗ cap.set для стабильности.&quot;&quot;&quot;&#10;    cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)&#10;&#10;    try:&#10;        while True:&#10;            success, frame = cap.read()&#10;            if not success:&#10;                break&#10;            frame = cv2.resize(frame, (640, 480))&#10;            try:&#10;                result = container.track_use_case.execute(frame)&#10;                frame_with_overlay = draw_overlays(frame, result)&#10;            except Exception as e:&#10;                print(f&quot;[ERROR] Ошибка в трекинге: {e}&quot;)&#10;                frame_with_overlay = frame&#10;&#10;            ret, buffer = cv2.imencode(&#10;                &quot;.jpg&quot;, frame_with_overlay, [cv2.IMWRITE_JPEG_QUALITY, 70]&#10;            )&#10;            frame_bytes = buffer.tobytes()&#10;&#10;            yield (&#10;                b&quot;--frame\r\n&quot;&#10;                b&quot;Content-Type: image/jpeg\r\n\r\n&quot; + frame_bytes + b&quot;\r\n&quot;&#10;            )&#10;    finally:&#10;        cap.release()&#10;&#10;&#10;@monitor_bp.route(&quot;/video_feed&quot;)&#10;def video_feed():&#10;    return Response(&#10;        generate_frames(), mimetype=&quot;multipart/x-mixed-replace; boundary=frame&quot;&#10;    )&#10;&#10;&#10;@monitor_bp.route(&quot;/logs&quot;, methods=[&quot;GET&quot;])&#10;def get_logs():&#10;    # Диагностика: логируем вызов эндпоинта и источник запроса&#10;    print(f&quot;[MONITOR] GET /api/v1/monitor/logs called from {request.remote_addr} method={request.method}&quot;)&#10;    try:&#10;        report = container.report_use_case.execute()&#10;        if report is None:&#10;            print(&quot;[MONITOR] report_use_case.execute() вернул None, возвращаю пустой список&quot;)&#10;            return jsonify([])&#10;&#10;        # Если report содержит объекты, не сериализуемые напрямую, попробуем привести к простому виду&#10;        try:&#10;            return jsonify(report)&#10;        except Exception as ser_exc:&#10;            print(f&quot;[MONITOR] Ошибка сериализации ответа: {ser_exc}. Попытка привести в список словарей.&quot;)&#10;            # Попытка трансформировать итерацию объектов в словари (без предположений об атрибутах)&#10;            try:&#10;                safe = []&#10;                for item in report:&#10;                    if isinstance(item, dict):&#10;                        safe.append(item)&#10;                    else:&#10;                        # берём атрибуты доступные через __dict__ как fallback&#10;                        attrs = getattr(item, &quot;__dict__&quot;, None)&#10;                        if attrs:&#10;                            safe.append({k: (v.isoformat() if hasattr(v, &quot;isoformat&quot;) else v) for k, v in attrs.items()})&#10;                        else:&#10;                            safe.append(str(item))&#10;                return jsonify(safe)&#10;            except Exception as convert_exc:&#10;                print(f&quot;[MONITOR] Не удалось привести отчет в JSON: {convert_exc}&quot;)&#10;                return jsonify({&quot;error&quot;: &quot;Failed to serialize report&quot;, &quot;debug&quot;: str(convert_exc)}), 500&#10;    except Exception as e:&#10;        import traceback&#10;&#10;        traceback.print_exc()&#10;        print(f&quot;[MONITOR] Ошибка при получении логов: {e}&quot;)&#10;        return jsonify({&quot;error&quot;: str(e)}), 500&#10;&#10;&#10;@monitor_bp.route(&quot;/groups&quot;, methods=[&quot;GET&quot;])&#10;def get_groups():&#10;    students = container.student_repo.get_all()&#10;    groups = {}&#10;    for s in students:&#10;        if s.group_name not in groups:&#10;            groups[s.group_name] = []&#10;        groups[s.group_name].append(&#10;            {&quot;id&quot;: s.id, &quot;name&quot;: s.name, &quot;photo&quot;: f&quot;/static/images/{s.id}.jpg&quot;}&#10;        )&#10;&#10;    for g in groups:&#10;        groups[g].sort(key=lambda x: x[&quot;name&quot;])&#10;    return jsonify(groups)&#10;&#10;&#10;@monitor_bp.route(&quot;/manual_status&quot;, methods=[&quot;POST&quot;])&#10;def manual_status():&#10;    # добавлен лог для диагностики входящих данных&#10;    try:&#10;        data = request.get_json(force=False, silent=True) or request.json or {}&#10;    except Exception:&#10;        data = request.json or {}&#10;&#10;    print(f&quot;[MONITOR] POST /api/v1/monitor/manual_status payload from {request.remote_addr}: {data}&quot;)&#10;&#10;    student_id = data.get(&quot;student_id&quot;)&#10;    action = data.get(&quot;action&quot;)&#10;&#10;    from src.backend.domain.attendance.entity import AttendanceLog, EngagementStatus&#10;    from datetime import datetime&#10;&#10;    log = AttendanceLog(&#10;        id=None,&#10;        student_id=student_id,&#10;        timestamp=datetime.now(),&#10;        is_late=False,&#10;        engagement_score=(&#10;            EngagementStatus.HIGH if action == &quot;present&quot; else EngagementStatus.LOW&#10;        ),&#10;    )&#10;    container.attendance_repo.add_log(log)&#10;    print(f&quot;[MONITOR] Добавлен лог вручную для student_id={student_id} action={action}&quot;)&#10;    return jsonify({&quot;status&quot;: &quot;updated&quot;})" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>